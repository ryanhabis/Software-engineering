# Software-engineering
Here’s a focused breakdown of the topics you mentioned, tailored to your exam preparation:

### **1. Software Engineering Principles**  
- **Key Principles**:  
  - **Separation of Concerns**: Break systems into smaller, focused parts (e.g., MVC architecture).  
  - **Modularization**: Independent modules improve reusability (e.g., microservices).  
  - **Abstraction**: Hide implementation details (e.g., APIs, GUI interactions).  
  - **Generality**: Design reusable solutions without overcomplicating (e.g., libraries/frameworks).  
  - **Anticipation of Change**: Follow the *open-closed principle* (extendable without modifying core code).  
  - **Incrementality**: Agile/iterative development (e.g., MVP releases).  
  - **Rigor & Formality**: Use precise methods like UML for critical systems.  

---

### **2. Software Patterns vs. Antipatterns**  
- **Design Patterns** (Reusable Solutions):  
  - **Creational**: Singleton, Factory (manage object creation).  
  - **Structural**: Adapter, Decorator (simplify system composition).  
  - **Behavioral**: Observer, Strategy (define object interactions).  
- **Antipatterns** (Harmful Practices):  
  - **Spaghetti Code**: Unstructured, hard-to-maintain logic.  
  - **God Object**: One class handling too many responsibilities.  
  - **Premature Optimization**: Optimizing before identifying bottlenecks.  

---

### **3. Algorithms**  
- **Key Concepts**:  
  - **Efficiency**: Big-O notation (e.g., O(1), O(n log n)).  
  - **Sorting**: QuickSort (divide-and-conquer), MergeSort (stable).  
  - **Searching**: Binary Search (O(log n) on sorted data).  
  - **Graph Algorithms**: Dijkstra’s (shortest path), DFS/BFS (traversal).  

---

### **Example Exam Question**  
**Q**: *Explain how modularization improves software maintainability.*  
**A**: Modularization divides a system into independent modules, each handling a specific task. This reduces complexity, isolates errors, and allows updates to one module without affecting others, speeding up development and debugging.  
